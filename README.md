# Java- InterviewQuestions
## 每日六道JAVA常见面试题分享
# 2019-06-01 
### 腾讯的Java面试题
1.TCP和UDP的区别，TCP为什么是三次握手，不是两次。

        因为tcp是全双工协议，区别在于前者可靠，后者不可靠，以及效率更高。
        
### Dubbo面试题
2.dubbo和dubbox之间的区别？

        Dubbox 和Dubbo本质上没有区别，名字的含义扩展了Dubbo而已，以下扩展出来的功能
        支持REST风格远程调用（HTTP + JSON/XML)；
        支持基于Kryo和FST的Java高效序列化实现；
        支持基于Jackson的JSON序列化；
        支持基于嵌入式Tomcat的HTTP remoting体系；
        升级Spring至3.x；
        升级ZooKeeper客户端；
        支持完全基于Java代码的Dubbo配置；
        
        
### Java List面试题
3.ArrayList和LinkedList的区别？分别用在什么场景？

        ①ArrayList和LinkedList可想从名字分析，它们一个是Array(动态数组)的数据结构，一个是Link(链表)的数据结构，此外，它们两个都是对List接口的实现。
        前者是数组队列，相当于动态数组；后者为双向链表结构，也可当作堆栈、队列、双端队列
        ②当随机访问List时（get和set操作），ArrayList比LinkedList的效率更高，因为LinkedList是线性的数据存储方式，所以需要移动指针从前往后依次查找。
        ③当对数据进行增加和删除的操作时(add和remove操作)，LinkedList比ArrayList的效率更高，因为ArrayList是数组，所以在其中进行增删操作时，会对操作点之后所有数据的下标索引造成影响，需要进行数据的移动。
        ④从利用效率来看，ArrayList自由性较低，因为它需要手动的设置固定大小的容量，但是它的使用比较方便，只需要创建，然后添加数据，通过调用下标进行使用；而LinkedList自由性较高，能够动态的随数据量的变化而变化，但是它不便于使用。
        ⑤ArrayList主要控件开销在于需要在lList列表预留一定空间；而LinkList主要控件开销在于需要存储结点信息以及结点指针信息。
        场景：
        链表，插入删除快，查找修改慢。  适用于频繁增删的场景。
        数组，查找快，插入删除慢。  适用于频繁查找和修改的场景。

### Java Map集合面试题
4.Collection集合接口和Map接口有什么关系？

        没有直接关系，但是一些子类会有依赖，Collection是最基本的集合接口，声明了适用于JAVA集合（只包括Set和List）的通用方法。Map接口并不是Collection接口的子接口，但是它仍然被看作是Collection框架的一部分。

### Spring面试题
5.什么是Spring的内部bean？

        当一个bean只能被某一个类使用时，称该bean为内部bean。

### Zookeeper面试题
6.zookeeper是什么框架？

        ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务。


# 2019-06-02 
### 腾讯的Java面试题
1.说说Java中异常的分类。

        异常分类：
        Throwable -> Error,Exception
        Error:严重问题，例如内存溢出
        Exception ->运行时异常： RuntimeException，编译时异常
        AWTError
        
### Dubbo面试题
2.一般使用什么注册中心，还有别的选择吗？

        Dubbo 一般用zookeeper做注册中心
        还可以用：Redis,数据库，consul
        
        
### Java List面试题
3.怎么给List排序？

        List 如何排序：
        ①：使用  Collections.sort 默认正序，可以传第二个参数自定义排序
        ②：自定义bean实现 Comparable 接口。
        ③： 实现Comparator接口自定义比较器

### Java Map集合面试题
4.你都知道哪些Map集合？

        HashMap、HashTable、TreeMap、LinkedHashMap

### Spring面试题
5.为什么说Spring是一个容器？

        Spring的核心理念就是更方便地管理Java Bean，而被管理的Java Bean存缓存在一个Map中，这个Map就可以理解为用来装Java Bean的容器，即IOC容器。

### JVM面试题
6.说说Java虚拟机的生命周期及体系结构？

        JVM的生命周期：
        JVM实例：一个独立运行的java程序，是进程级别
        JVM执行引擎：用户运行程序的线程，是JVM实例的一部分
        1.  JVM实例的诞生
        当启动一个java程序时.一个JVM实例就诞生了，任何一个拥有public static void main(string[] args)的函数都可以作为实例的运行启点
        2.  JVM实例运行
        main作为程序初始化线程的起点,任何其他线程由其启动。
        JVM有两种线程：守护线程和非守护线程。守护线程由JVM使用。main启动后将是非守护线程。
        3.  JVM实例消亡
        当程序中所有非守护线程都中止时,JVM退出；若安全管理器允许，程序也可以使用Runtime类或者System.exit()退出。
        
        JVM的体系结构:
        1.  Class Loader 类加载器
        类加载器的作用是加载类文件到内存，ClassLoader只管加载，只要符合文件结构就加载，至于说能不能运行，则不是它负责的，那是由Execution Engine负责，只要符合《JVM Specification》中式这样定义Class文件的结构。
        2.  Execution Engine 执行引擎
        执行引擎也叫做解释器(Interpreter)，负责解释命令，提交操作系统执行。
        3.  Native Interface本地接口
        本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合C/C++程序，的具体做法是Native Method Stack中登记native方法，在Execution Engine执行时加载native libraies。
        4.  Runtime data area运行数据区
        运行数据区是整个JVM的重点。我们所有写的程序都被加载到这里，之后才开始运行。
        整个JVM框架由加载器加载文件，然后执行器在内存中处理数据，需要与异构系统交互是可以通过本地接口进行。
   
# 2019-06-03 
### 
1.Java 是如何实现跨平台的？
###### 注意：跨平台的是 Java 程序，而不是 JVM。JVM 是用 C/C++ 开发的，是编译后的机器码，不能跨平台，不同平台下需要安装不同版本的 JVM
        答：我们编写的 Java 源码，编译后会生成一种 .class 文件，称为字节码文件。Java 虚拟机（JVM）就是负责将字节码文件翻译成特定平台下的机器码然后运行，也就是说，只要在不同平台上安装对应的 JVM，就可以运行字节码文件，运行我们编写的 Java 程序。
        而这个过程，我们编写的 Java 程序没有做任何改变，仅仅是通过 JVM 这一 “中间层” ，就能在不同平台上运行，真正实现了 “一次编译，到处运行” 的目的。
        
### 
2.什么是 JVM ？
###### 解析：不仅仅是基本概念，还有 JVM 的作用。
        答：JVM，即 Java Virtual Machine，Java 虚拟机。它通过模拟一个计算机来达到一个计算机所具有的的计算功能。
        JVM 能够跨计算机体系结构来执行 Java 字节码，主要是由于 JVM 屏蔽了与各个计算机平台相关的软件或者硬件之间的差异，使得与平台相关的耦合统一由 JVM 提供者来实现。
        
        
### 
3.JVM 由哪些部分组成？
###### 解析：这是对 JVM 体系结构的考察
        答：JVM 的结构基本上由 4 部分组成：
        类加载器，在 JVM 启动时或者类运行时将需要的 class 加载到 JVM 中
        执行引擎，执行引擎的任务是负责执行 class 文件中包含的字节码指令，相当于实际机器上的 CPU
        内存区，将内存划分成若干个区以模拟实际机器上的存储、记录和调度功能模块，如实际机器上的各种功能的寄存器或者 PC 指针的记录器等
        本地方法调用，调用 C 或 C++ 实现的本地方法的代码返回结果

### 
4.类加载器是有了解吗？
###### 解析：底层原理的考察，其中涉及到类加载器的概念，功能以及一些底层的实现。
        答：顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。
        
        类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。

### 
5.Java 虚拟机是如何判定两个 Java 类是相同的？
   
        答：Java 虚拟机不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。即便是同样的字节代码，被不同的类加载器加载之后所得到的类，也是不同的。
        比如一个 Java 类 com.example.Sample，编译之后生成了字节代码文件 Sample.class。两个不同的类加载器 ClassLoaderA和 ClassLoaderB分别读取了这个 Sample.class文件，并定义出两个 java.lang.Class类的实例来表示这个类。
        这两个实例是不相同的。对于 Java 虚拟机来说，它们是不同的类。试图对这两个类的对象进行相互赋值，会抛出运行时异常 ClassCastException。
        
### 
6.类似-Xms、-Xmn这些参数的含义：

        答：
        堆内存分配：
        JVM初始分配的内存由-Xms指定，默认是物理内存的1/64
        JVM最大分配的内存由-Xmx指定，默认是物理内存的1/4
        默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制；空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。
        因此服务器一般设置-Xms、-Xmx相等以避免在每次GC 后调整堆的大小。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。
        非堆内存分配：
        JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；
        由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。
        -Xmn2G：设置年轻代大小为2G。
        -XX:SurvivorRatio，设置年轻代中Eden区与Survivor区的比值。
       
# 2019-06-04 
### 
1.sleep()和wait(n)、wait()的区别？

        答：sleep 方法： 
        是 Thread 类的静态方法，当前线程将睡眠 n 毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进行可运行状态，等待 CPU 的到来。睡眠不释放锁（如果有的话）；
        
        wait 方法： 
        是 Object 的方法，必须与 synchronized 关键字一起使用，线程进入阻塞状态，当 notify 或者 notifyall 被调用后，会解除阻塞。但是，只有重新占用互斥锁之后才会进入可运行状态。睡眠时，释放互斥锁。
        
        
### 
2.synchronized关键字？

        答：底层实现：
        进入时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；
        当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。
        含义：（monitor 机制）
        Synchronized 是在加锁，加对象锁。对象锁是一种重量锁（monitor），synchronized 的锁机制会根据线程竞争情况在运行时会有偏向锁（单一线程）、轻量锁（多个线程访问 synchronized 区域）、对象锁（重量锁，多个线程存在竞争的情况）、自旋锁等。
        该关键字是一个几种锁的封装。
        
### 
3.volatile关键字？
###### 解析：关于指令重排序的问题，可以查阅 DCL 双检锁失效相关资料。
        答：该关键字可以保证可见性不保证原子性。
        功能：     
        主内存和工作内存，直接与主内存产生交互，进行读写操作，保证可见性；
        禁止 JVM 进行的指令重排序。
        

### 
4.volatile能使得一个非原子操作变成原子操作吗？

        答：能。
        一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。
        
### 
5.ThreadLocal(线程局部变量)关键字？
   
        答：当使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。
        ThreadLocal 内部实现机制：
        每个线程内部都会维护一个类似 HashMap 的对象，称为 ThreadLocalMap，里边会包含若干了 Entry（K-V 键值对），相应的线程被称为这些 Entry 的属主线程；
        Entry 的 Key 是一个 ThreadLocal 实例，Value 是一个线程特有对象。Entry 的作用即是：为其属主线程建立起一个 ThreadLocal 实例与一个线程特有对象之间的对应关系；
        Entry 对 Key 的引用是弱引用；Entry 对 Value 的引用是强引用。
        
### 
6.我们为什么要使用线程池？核心线程池内部实现了解吗？

        答： 
        减少创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
        可以根据系统的承受能力，调整线程池中工作线程的数目，放置因为消耗过多的内存，而把服务器累趴下（每个线程大约需要 1 MB 内存，线程开的越多，消耗的内存也就越大，最后死机）
        
        对于核心的几个线程池，无论是 newFixedThreadPool() 方法，newSingleThreadExecutor() 还是 newCachedThreadPool() 方法，虽然看起来创建的线程有着完全不同的功能特点，
        但其实内部实现均使用了 ThreadPoolExecutor 实现，其实都只是 ThreadPoolExecutor 类的封装。
        
        
# 2019-06-05
### 
1.解释AOP模块？

        答：AOP（Aspect-Oriented Programming）指一种程序设计范型，该范型以一种称为切面（aspect）的语言构造为基础，切面是一种新的模块化机制，用来描述分散在对象、类或方法中的横切关注点（crosscutting concern）。
        
### 
2.有哪些不同的IOC(依赖注入)方式？

        答：构造器依赖注入： 构造器依赖注入通过容器触发一个类的构造器来实现的，该类有一系列参数，每个参数代表一个对其他类的依赖。 
          Setter方法注入： Setter方法注入是容器通过调用无参构造器或无参static工厂 方法实例化bean之后，调用该bean的setter方法，即实现了基于setter的依赖注入。
        
### 
3.你怎样定义类的作用域？

        答：当定义一个 在Spring里，我们还能给这个bean声明一个作用域。它可以通过bean 定义中的scope属性来定义。如，当Spring要在需要的时候每次生产一个新的bean实例，bean的scope属性被指定为prototype。另一方面，一个bean每次使用的时候必须返回同一个实例，这个bean的scope 属性 必须设为 singleton。
        

### 
4.Spring框架的事务管理有哪些优点？

        答：它为不同的事务API 如 JTA，JDBC，Hibernate，JPA 和JDO，提供一个不变的编程模式。 
          它为编程式事务管理提供了一套简单的API而不是一些复杂的事务API如 
          它支持声明式事务管理。 
          它和Spring各种数据访问抽象层很好得集成。
        
### 
5.什么是SpringMVC框架的控制器？
   
        答：控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个由视图呈现给用户的模型。Spring用一个非常抽象的方式实现了一个控制层，允许用户创建多种用途的控制器。
        
### 
6.在SpringAOP中，关注点和横切关注的区别是什么？

        答： 
        关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。 
        横切关注点是一个关注点，此关注点是整个应用都会使用的功能，并影响整个应用，比如日志，安全和数据传输，几乎应用的每个模块都需要的功能。因此这些都属于横切关注点。
   
              
# 2019-06-10
### 
1.使用Spring框架的好处是什么？

        答：轻量： Spring 是轻量的，基本的版本大约2MB。 
        控制反转： Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找依赖的对象们。 
        面向切面的编程(AOP)： Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 
        容器： Spring 包含并管理应用中对象的生命周期和配置。 
        MVC框架： Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 
        事务管理： Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务（JTA）。 
        异常处理： Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛出的）转化为一致的unchecked 异常。
        
### 
2.Spring由哪些模块组成？

        答：以下是Spring 框架的基本模块：
        Core module 
        Bean module 
        Context module 
        Expression Language module 
        JDBC module 
        ORM module 
        OXM module 
        Java Messaging Service(JMS) module 
        Transaction module 
        Web module 
        Web-Servlet module 
        Web-Struts module 
        Web-Portlet module

        
### 
3.BeanFactory-BeanFactory实现举例？

        答：Bean 工厂是工厂模式的一个实现，提供了控制反转功能，用来把应用的配置和依赖从正真的应用代码中分离。
        最常用的BeanFactory 实现是XmlBeanFactory 类。

### 
4.什么是SpringIOC容器？

        答：Spring IOC 负责创建对象，管理对象（通过依赖注入（DI），装配对象，配置对象，并且管理这些对象的整个生命周期。
        
### 
5.IOC的优点是什么？
   
        答：IOC 或 依赖注入把应用的代码量降到最低。它使应用容易测试，单元测试不再需要单例和JNDI查找机制。最小的代价和最小的侵入性使松散耦合得以实现。IOC容器支持加载服务时的饿汉式初始化和懒加载。
        
### 
6.什么是基于注解的容器配置？

        答：相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。
        开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml表述bean的装配关系。
        
# 2019-06-11
### 
1.什么是Spring MVC框架的控制器？

        答：控制器提供一个访问应用程序的行为，此行为通常通过服务接口实现。控制器解析用户输入并将其转换为一个呦视图呈现给用户的模型。
        Spring用一个非常抽象的方法实现了一个控制层，允许用户创建多种用途的控制器。
        
### 
2.什么是基于注解的容器配置？

        答：相对于XML文件，注解型的配置依赖于通过字节码元数据装配组件，而非尖括号的声明。
        开发者通过在相应的类，方法或属性上使用注解的方式，直接组件类中进行配置，而不是使用xml标书bean的装配关系。

        
### 
3.怎样开启注解装配？

        答：注解装配在默认情况下是不开启的，为了使用注解装配，我们必须在Spring配置文件中配置元素。

### 
4.@Required注解？

        答：这个注解表明bean的属性必须在配置的时候设置，通过一个bean定义的显式的属性值或通过自动装配，若@Required注解的bean属性
        未被设置，容器将抛出BeanInitializationException。
        
###
5.@Autowired注解？
   
        答：@Autowired注解提供了更细粒度的控制，包括在何处以及如何完成自动装配。它的用法和@Required一样，修饰setter方法、构造器、属性或者
        具有任意名称和/或多个参数的PN方法。
        
### 
6.@Qualifier注解？

        答：当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowire注解结合使用以消除这种混淆，指定需要装配的确切的bean。


# 2019-06-12
### 
1.什么是Mybatis？

        答：（1）Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。       
          （2）MyBatis 可以使用 XML 或注解来配置和映射原生信息，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
          （3）通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和 statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。
        
### 
2.Mybaits的优点？

        答：（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。
          （2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；
          （3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。
          （4）能够与Spring很好的集成；
          （5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。
        
### 
3.MyBatis框架的缺点？

        答：（1）SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求。
          （2）SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。

### 
4.MyBatis框架适用场合？

        答：（1）MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。
          （2）对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。
        
### 
5.MyBatis与Hibernate有哪些不同？
   
        答：（1）Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。
          （2）Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，因为这类软件需求变化频繁，一但需求变化要求迅速输出成果。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。 
          （3）Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件，如果用hibernate开发可以节省很多代码，提高效率。
        
### 
6.Mybatis是如何进行分页的？分页插件的原理是什么？

        答：Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页。可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。
          分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。
          
# 2019-06-13
### 
1.Mybatis动态sql有什么用？执行原理？有哪些动态sql？

        答：Mybatis动态sql可以在xml映射文件内，以标签的形式编写动态sql，执行原理是根据表达式的值，完成逻辑判断并动态拼接sql的功能。
        Mybatis提供了9种动态sql标签：trim | where | set | foreach | if | choose | when | otherwise | bind.
        
### 
2.Xml映射文件中，除了常见的select|insert|update|delete标签之外，还有哪些标签？

        答：<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签引入sql片段，
        <selectKey>为不支持自增的主键生成策略标签。
        
### 
3.为什么说MyBatis是半自动ORM映射工具？它与全自动的区别在哪里？

        答：Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。
        而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。

### 
4.MyBatis实现一对一有几种方式？具体怎么操作的？

        答：有联合查询和嵌套查询，联合查询是几个表联合查询，只查询一次，通过resultMap里面配置association节点配置一对一的类就可以完成；
        嵌套查询是先查一个表，根据这个表里面的结果的外键id，去在另外一个表里面查询数据，也是通过association配置，但另外一个表的查询通过select属性配置。
        
### 
5.MyBatis实现一对多有几种方式，怎么操作的？
   
        答：有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过resultMap里面的collection节点配置一对多的类就可以完成；
        嵌套查询是先查一个表，根据这个表里面的结果的外键id，去在另外一个表里面查询数据，也是通过配置collection，但另外一个表的查询通过select节点配置。
        
### 
6.Mybatis的一级、二级缓存？

        答：1）一级缓存：基于PerpetualCache的HashMap本地缓存，其存储作用域为Session，当Session flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存。
        2）二级缓存与一级缓存其机制相同，默认也是采用PerpetualCache、HashMap存储，不同在于其存储作用域为Mapper(namespace)，并且可自定义存储源，如Ehcache。
        默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态)，可在它的映射文件中配置<cache>;
        3）对于缓存数据更新机制，当某一个作用域（一级缓存Session/二级缓存Namespaces）的进行了C/U/D操作后，默认该作用域下所有select中的缓存将被clear。
    
# 2019-06-14
### 
1.equal 和 hashcode 作用和区别？

        答：首先，我们要明白hashCode()和equals()方法的作用是什么，然后才能说它的区别，说了区别之后再说嘛使用的时候需要注意的地方，这样的回答思路基本OK的。
        一、hashCode()和equals()的作用是什么？
        hashCode()和equals()的作用其实是一样的，目的都是为了在java里面比较两个对象是否相等一致。
        二、hashCode()和equals()的区别是什么？
        我们可以从两个角度分别介绍它们的区别：一个是性能，一个是可靠性。它们的主要区别体现在这里
        （1）equals()既然已经实现比较两个对象的功能了，为什么还需要hashCode()呢？因为重写的equals()里面一般比较的较为全面和复杂（它会对这个对象内所有成员变量一一进行比较），
        这样效率很低，而通过hashCode()对比，则只要生成一个hash值就能比较了，效率很高。
        （2）那hashCode()的效率这么高，为什么还要用equals()呢？因为hashCode()并不是完全可靠，非常有可能的情况是，两个完全不同的对象的hash值却一样。
        所以会有下面三个重要的结论：
        * equals()相等的两个对象他们的hashCode()肯定相等，即equals()绝对可靠。
        * hashCode()相同的两个对象，它们的equals()不一定相同，即用hashCode()比较相同的时候不靠谱。
        * hashCode()不同的两个对象，它们的equals()肯定不同，即用hashCode()比较不同的时候肯定靠谱。
        三、hashCOde()和equals()使用的注意事项
        （1）对于需要大量并且快速的对比的话，如果都用equals()去做显然效率太低，所以解决方案为：每当需要比较的时候，首先用hashCode()去对比，而如果hashCode()不一样，则两个对象肯定不一样，此时就没有必要再用equals()比较了；
        如果hashCode()相同，则这两个对象有可能相同，这时候再去比较这两个对象的equals()，如若equals()也想同，则表示这两个真的相同，这样既大大提高了效率，又保证了准确性。
        （2）事实上，我们平时用的集合框架中的hashMap、hashSet、hashTable中对key的比较就是使用上述这种方法。
        （3）而Object默认的equals和hashCode方法返回的是对象的地址相关信息。所以当我们通过new关键字创建了两个内容相同的对象，虽然它们的内容相同，但是它们在内存中分配的地址不同，导致它们的hashCode()不同，
        这肯定不是我们想要的。所以当我们要讲某个类应用到集合中去的时候，就必须重写equals()方法和hashCode()方法。
        四、扩展
        （1）阿里巴巴开发规约明确规定：
        * 只要重写了equals()方法，就必须重写hashCode()方法
        * 因为set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法
        * 如果对象定义为Map的键，那么就必须重写equals()方法和hashCode()方法
        * String重写了equals()方法和hashCode()方法，所以我们可以非常愉快的使用String对象作为key
        （2）是不是每个对象都要重写这两个方法，到底什么时候重写？
        * 事实上一般情况下，我们并不需要重写这两个方法，只有该类被应用到集合框架中去的时候，才应该重写。
        （3）我们能不能只重写equals()方法，不重写hashCode()方法？
        * 如果重写了equals()方法，比如说基于对象的内容实现的，而保留了hashCode()的实现不改变，name最终出现的情况很可能是，两个对象明明是“相等的”，但是hashCode()却不一样，这不是我们想要的
        （4）为什么需要hashCode()
        * 通过hashCode()可以提高对比的性能
### 
2.如何保证单机保证3w tps 访问量？

        答：
        解答一：
        今天面试被问到一个问题，如何保证单机保证3wtps的访问量？
        听到这个问题，第一反应有点懵，想成了3w的并发量了，想了一下，目前的容器比如Tomcat的最大并发量也就几千就扛不住了。。。
        后来我先说了IO模型使用NIO，能够处理小数据大并发的请求，然后从代码优化上说要尽量并行处理逻辑，以及优化JVM，调整堆大小，减少FullGC，使停顿时间减少，最终使每个请求的处理时间减少。
        但是也知道这个说法听不搭题的。。。。后来面试官跟我说从两个方面来分析，一方面是从请求上来说，将多个请求合并成一个请求发送，减少请求次数，一方面是把请求都改成异步的，后台处理，让请求过来之后就直接返回成功。
        当时感觉这两个方面说的也没问题。回来的路上，也一直在思考这个问题，有了些想法：
        （1）首先从题目的说明上，本身存在的一些问题，说的是要保证3w的tps，但是如果将请求合并了，时间少了请求次数，但是也达不到3w的tps了，这样本身就不符合这个题目的要求了，所以我认为要修改题目的说明，要么这个3w tps就是
        一个固定值，无法通过外部优化来减少了，只能从系统内部去优化。
        （2）然后从系统优化来说，这个题目本身也存在一定的问题，就是这个3w的tps到底是峰值流量还是平时流量，是需要同步给出处理结果，还是可以接受异步的后续返回处理结果。
        如果是需要同步给出处理结果，那么就只能从业务处理流程上进行优化，也就是尽量把串行的处理流程改成并行的处理流程，把查询尽量从数据库改到缓存中。但是即使这样，一个需要同步返回结果的3w tps单机处理，每个请求的
        处理时间=1%3000≈0.00033秒=0.33微妙,感觉在事件上是根本无法处理完一个业务流程的。如果一个业务流程无法处理完的话，name请求就会出现堆积现象，堆积过多就会出现OOM，内存溢出了。。。
        所以我个人感觉这个单机3w同步处理的优化是不符合现实的，只能从业务上去处理，尽量把同步到业务逻辑改成异步的业务逻辑，即使改成异步的业务逻辑，索然能够支撑3w的tps,但是因为服务的处理速刷无法达到3w tps的处理速度，
        那么最终会造成内存的不断消耗，最终导致OOM的出现。
        （3）看这个tps到底是峰值还是平时了，如果只是峰值3w，平时很低，而且可以使用异步的话，那么久可以使用MQ了，请求过来直接把请求发送到MQ中去，不处理业务。然后创建消费者去消费这些消息，达到削峰填谷的目的。
        （4）计算一下，如果一个请求的处理时间是10ms,那么单线程每秒的处理速度=100%10=100个，采用并行处理，如果是一个四核八线程的处理器，理论上创建16个线程去处理，那么每秒的处理速度=100*16=1600个，不知道这样的计算方法是否正确。
        
        解答二：
        个人认为这类题，没有标准答案，无非是问分布式怎么解决高并发，怎么回答都行，较真你就输了，面试官其实就是想问你如何突破性能瓶颈，3w tps一般的需要依赖关系型数据库的应用是根本无法处理的，所以必须做异步，MQ等都是很好的方案，
        3w tps只能保证AP，无法保证数据强一致性，就采用BASE理论的最终一致性来解决，还有一点就是3w tps 不是3w的并发(一个应用如果要支持上万连接数的开关本身就很耗性能，基本没有资源做业务了)，所以又有一个考点就是建立长连接，发批量数据包
        也就是面试官说的合并请求，但是数据包也不能过大，所有这些都是有场景的，再说一点NIO并不一定比BIO性能更高，如果worker线程处理的都是耗时操作（比如操作数据库），性能并不会提高，只是NIO会比BIO提高资源利用率，所以一个串行调用链中的
        任何一个环节阻塞都会影响性能，你的这些计算的方法本身就有问题，一个请求消耗1秒的话，单线程和多线程处理10个请求需要的时间是一样的吗？你了解下nginx、redis、nodejs是怎么处理10万tps的能力的，应该就明白了。
        
### 
3.讲一下模版模式和策略模式的区别？

        答：模板方法模式的主要思想：定义一个算法流程，将一些特定步骤的具体实现、延迟到子类。使得可以再不改变算法流程的情况下，通过不同的子类，来实现“定制”流程中的特定的步骤。
        策略模式的主要思想：使不同的算法可以被相互替换，而不影响客户端的使用。

### 
4.redis和MQ如何平滑的扩容与缩容？

        答：MQ的消息是存放在内存或者磁盘中的，在缩减集群数量时，必须要迁移节点的数据。增加节点时，要重新配置集群。这么看来是无法平滑缩容和扩容的。
        
### 
5.MQ的消息生产比消费速度快得多，有什么解决方案吗？
   
        答：生产消息比消费速度快很多，这个本身是没有问题的，因为MQ的一个作用就是削峰。
        如果要提高消费速度，可以增加多个消费者。
        
### 
6.feign如何实现负载均衡，与Ribbon的负载均衡有什么区别？

        答：Feign一般用Ribbon来实现负载均衡。
        与Ribbon的负载均衡的区别？我觉得2个是不一样的东西，Feign已经包含了Ribbon，需要配合使用，一般生产环境用的是SpringCloud技术来整合的，当然也可以用其它技术来替代。Feign作为客户端Ribbon作为负载均衡，
        Eureka作为注册中心，Zuul作为网关，Security作为安全OAuth2认证
        首先得知道Feign和Ribbon是什么，然后具体怎么实现可以参考官网Feign:申明式Web服务客户端申明式：接口声明、Annotation驱动Web服务：Http的方式作为通讯协议客户端：用于服务调用的存根假设，有一个java接口UserService,
        Feign可以将其声明它是以http方式调用的。
        Ribbon：客户端负载均衡器，可以对Http和Tcp客户端的行为进行控制。
    
# 2019-06-17
### 
1.使用ExecutorService、Callable、Future实现有返回结果的线程？

        答：ExecutorService、Callable、Future三个接口实际上都是属于Executor框架。返回结果的线程是在JDK1.5中引入的新特性，有了这种特征就不需要再为了得到返回值而大费周折了。而且自己实现了也可能漏洞百出。
        可返回值的任务必须实现Callable接口。类似的，无返回值的任务必须实现Runnable接口。
        执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了。
        注意：get方法是阻塞的，即：线程无返回结果，get方法会一直等待。
        再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。
        
### 
2.Thread 类中的start() 和 run() 方法有什么区别？

        答：（1）start()方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。然后通过
        此Thread类调用方法run()来完成其运行操作，这里方法run()称为线程体，它包含了要执行的这个线程的内容，Run方法运行结束，此线程终止。然后CPU再调度其它线程。
        （2）run()方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码；程序中只有主线程——这一个线程，其程序执行路径还是只有一条，这样就没有达到写线程的目的。
        记住：多线程就是分是利用CPU，宏观上让所有线程一起执行，也叫并发。
        
### 
3.Java内存模型是什么？

        答：Java内存模型规定和指引Java程序在不同的内存架构、CPU和操作系统间有确定性地行为。它在多线程的情况下尤其重要。Java内存模型对一个线程所做的变动能被其它线程可见提供了保证，它们之间是先行发生关系。这个关系定义了一些规则让
        程序员在并发编程时思路更清晰。比如，先行发生关系确保了：线程内的代码能够按先后顺序执行，这被称为程序次序规则。
        对于同一个锁，一个解锁操作一定要发生在时间上后发生的另一个锁定操作之前，也叫做管程锁定规则。
        读操作之前，也叫volatile变量规则。
        一个线程内的任何操作必需在这个线程的start()调用之后，也叫作线程启动规则。
        一个线程的所有操作都会在线程终止之前，线程终止规则。
        一个对象的终结操作必需在这个对象构造完成之后，也叫对象终结规则。

### 
4.Java中的volatile 变量是什么？

        答：可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是这个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以
        对其它线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如volatile int a = 0;之后有一个操作a++；这个变量a具有可见性，但是a++依然是一个非原子操作，也就是这个操作同样存在线程安全问题。
        Java语言提供了一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其它线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，以此不会将该变量上的操作与其它内存操作一起重排序。volatile变量不会被缓存
        在寄存器或者对其它处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，因此volatile变量是一种比synchronized关键字更轻量级的同步机制。
        当对非volatile办理进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。如果计算机有哦多个CPU，每个线程可能在不同的CPU上处理，这意味着每个线程可以拷贝到不同的CPU cache中。而声明变量是volatile的，JVM保证了每次读变量都从内存中读，调过CPU cache这一步。
        当一个变量定义为volatile之后，将具备两种特性：保证此变量对所有的线程的可见性；禁止指令重排序优化。有volatile修饰的变量，赋值后多执行了一个“load addl $0x0,(%esp)”操作，这个操作相当于一个内存屏障（指令重排序时不能把后面的指令重排序到内存屏障之地的位置），
        只有一个CPU访问内存时，并不需要内存屏障；（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。
        
### 
5.什么是线程安全？Vector是一个线程安全类吗？
   
        答：如果你的diamante所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其它的变量的值也和预期的是一样的，就是线程安全的。
        一个线程安全的计数器类的同一个实例对象在被多个线程使用的情况下也不会出现计算失误。很显然你可以将集合类分成两组，线程安全和非线程安全的。Vector是用同步方法来实现线程安全的，而和它相似的ArrayList不是线程安全的。
        
### 
6.Java中notify 和 notifyAll有什么区别？

        答：notify()、notifyAll()的共同点：均能唤醒正在等待的线程，并且均是最后一个线程获取资源对象的锁。
        不同点：notify()只能唤醒一个线程，而notifyAll()能够唤醒所有的线程，当线程被唤醒以后所有被唤醒的线程竞争获取资源对象的锁，其中只有一个能够得到对象锁，执行代码。
        注意：wait()方法并不是在等待资源的锁，而是在等待被唤醒（notify()），一旦被唤醒后，被唤醒的线程就具备了资源锁（因为无需竞争），直至再次执行wait()方法或者synchronized代码块执行完毕。
        
# 2019-06-18
### 
1.前端浏览器地址的一个 http 请求到后端整个流程是怎么样？

        答：域名解析 --> 发起TCP的3次握手 --> 建立TCP连接后发起http请求 --> 服务器响应http请求，浏览器得到html代码 --> 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等） --> 浏览器对页面进行渲染呈现给用户
        
### 
2.公平锁和非公平锁？

        答：公平和非公平锁的队列都基于锁内部维护的一个双向链表，表节点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。
        非公平锁在等待锁的过程中，如果有任意新的线程妄图获取锁，都是有很大的几率直接获取到锁的
        （在ReentrantLock中很明显可以看到其中同步包括两种，分别是公平的FairSync和非公平的NonfairSync。公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。
        默认情况下ReentrantLock是通过非公平锁来进行同步的，包括synchronized关键字都是如此，因为这样性能会更好。因为从线程进入了RUNNABLE状态，可以执行开始，到实际线程执行是要比较久的时间的。而且，在一
        个锁释放之后，其它的线程会需要重新来获取锁。其中经历了持有锁的线程释放锁，其它线程从挂起恢复到RUNNABLE状态，其它线程请求锁，获得锁，线程执行，这一系列步骤。如果这个时候，存在一个线程直接请求锁，
        可能就避开挂起到恢复RUNNABLE状态的这段消耗，所以性能更优化）
        
### 
3.lock 和 synchronized 的区别？

        答：1）Lock是一个接口，而synchronized是java中的关键字，synchronized是内置的语言实现；
        2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要再finally块中释放锁；
        3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；
        4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到；
        5）Lock可以提高多个线程进行读操作的效率。
            在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。

### 
4.HashTable 你了解过吗？

        答：Hashtable既不支持Null key也不支持Null value。Hashtable的put()方法的注释中有说明Hashtable是线程安全的，它的每个方法都加入了synchronized方法，效率比较低；
        Hashtable默认的初始化大小为11，之后每次扩充，容量变为原来的2n+1。
        Hashtable在计算元素的位置时需要进行一次除法运算，儿除法运算是比较耗时的。
        
### 
5.Concurrenthashmap 是怎么做到线程安全的？
   
        答：Concurrenthashmap的大部分操作和HashMap相同，例如初始化，扩容和链表想红黑树的转变等。但是，在Concurrenthashmap中，大量使用了U.compareAndSwapXXX的方法，这个方法是利用一个CAS算法实现无锁化的修改值的操作，
        它可以大大降低锁代理的性能消耗。这个算法的基本思想就是不断地去比较当前内存中的变量值与你指定的一个变量值是否相等，如果相等，则接受你指定的修改的值，否则拒绝你的操作。因为当前线程中的值已经不是最新的值，你
        的修改很可能会覆盖掉其它线程修改的结果。这一点与乐观锁，SVN的思想是比较类似的。同时，在Concurrenthashmap中还定义了三个原子操作，用于对指定位置的节点进行操作。这三种原子操作被广泛的使用在Concurrenthashmap的
        get和put等方法中，正是这些原子操作保证了Concurrenthashmap的线程安全。
        在Concurrenthashmap没有出现以前，jdk使用hashtable来实现线程安全，但是hashtable是将整个hash表锁住，所以效率很低下。Concurrenthashmap将数据分别放到多个segment中，默认16个，每一个segment中又包含了多个HashEntry列表数组，
        对于一个key，需要经过三次hash操作，才能最终定位这个元素的位置，这三次hash分别为:
        对于一个key，先进行一次hash操作，得到hash值h1，也即h1 = hash1(key)；将得到的h1的高几位进行第二次hash，得到hash值h2，也即h2 = hash2(h1高几位)，通过h2能够确定该元素的放在哪个segment；将得到的h1进行第三次hash，得到hash
        值h3，也即h3 = hash3(h1)，通过h3能够确定该元素放置在哪个HashEntry。每一个segment都拥有一个锁，当进行写操作时，只需要锁定一个segment，而其它segment中的数据是可以访问的。
        
### 
6.如果存取相同的数据，ArrayList 和 LinkedList 谁占用空间更大？

        答：对于随机访问get和set，ArrayList觉得由于LinkedList,因为LinkeList要移动指针。
        对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据，若要从数组中删除或插入某一个对象，需要移动后段的数组元素，从而会重新调整索引顺序，调整索引顺序会
        消耗一定的时间，相反，LinkedList是使用链表实现的，若要从链表中删除或插入某一个对象，只需要改变前后对象的引用即可。
      
# 2019-06-19
### 
1.List，Map，Set三个接口存取元素时，各有什么特点？

        答：List以特定索引来存取元素，可以有重复元素，Set不能存放重复元素（用对象的equals方法来区别元素是否重复），Map保存键值对（Key - Value pair）映射，映射关系可以是一对一或多对一。
        Set和Map容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为O(1)，而基于排序树排班的实现在插入和删除元素时会按照元素或元素的键key构成排序树从而达到排序和去重的效果。
        
### 
2.Thread类的sleep（）方法和对象的wait（）方法都可以让线程暂停执行 它们有什么区别？

        答：sleep()方法是线程Thread的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会cpu让给其它线程，但是对象的锁依然保持，因此休眠时间结束后会自动修复线程回到就绪状态；
        wait()是Object类的方法，调用对象的wait()方法导致当前线程放弃对象的锁，线程暂停执行，进入对象的等待池wait pool，只有调用对象的notify()方法或者notifyAll()方法时才能唤醒等待池中的线程
        进入等锁池lock pool，如果线程重新获得对象的锁就可以进入就绪状态。
        
### 
3.线程的sleep（）方法和yield（）方法有什么区别？

        答：（1）sleep()方法给其它线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会。
        （2）线程执行sleep()方法后转入阻塞blocked状态而执行yield()方法后转入就绪ready状态。
        （3）sleep()方法声明抛出InterruptedException而yield()方法没有声明任何异常。
        （4）sleep()方法比yield()方法具有更好的可移植性。
        
### 
4.当一个线程进入一个对象的synchronized方法A之后 其他线程是否可进入此对象的synchronized方法b？

        答：不能，其它线程只能访问该对象的非同步方法，同步方法则不能进入，因为非静态方法上的synchronized修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，
        那么视图进入B方法的线程就只能在等锁池（注意不是等待池）中等待对象的锁。
        
### 
5.什么是线程池？ （thread pool）？
   
        答：在面向对象编程中创建和销毁对象是很浪费时间的，因为创建一个对象要获取内存资源或者其它更多资源，在Java中便是如此，虚拟机就将试图跟踪每一个对象，以便能够在对象销毁胡进行垃圾回收，所以
        提高服务程序效果的一个手段，就是尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁，这就是“池化资源”技术产生的原因。线程池顾名思义就是事先创建若干个可执行的线程放入一
        个池（容器）中，需要的时候从池中获取线程不用自己创建，使用完毕不需要销毁线程的，而是放回池中，从而减少创建和销毁线程对象的开销。
        Java5中的Executor接口定义一个执行线程的工具，它的子类型即线程池接口是ExecutorService，要配置一个线程池是比较复杂的，尤其是对线程池的原理不是很清楚的情况下，因此在工具类Executors里提供了
        一些静态工厂方法，生成一些常用的线程池，如下所示：
        newSingleThreadExecutor：创建一个单线程的线程池，这个线程池只有一个线程在工作，也即是相当于单线程串执行所有任务，如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它，此线程池保
        证所有的任务的执行属性按照任务的提交顺序执行。
        newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小，线程的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
        newCachedThreadPool：创建一个可缓存的线程池，如果线程池的大小超过处理任务所需要的线程，那么就会回收部分空闲(60秒不执行任务)的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务，
        此线程池不会对线程池大小做限制，线程池大小完全依赖与操作系统，或者说JVM能够创建的最大线程大小。
        newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。
        newSingleThreadExecutor：创建一个单线程的线程池，此线程池支持定时以及周期性执行任务的需求。
        
### 
6.举例说明同步和异步？

        答：如果系统存在临界资源，资源数量少于竞争资源的线程数量的资源，例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能被另一个线程写过了，那么这些数据就必须进行同步存取，
        数据库操作中的排它锁就是最好的例子，当应用程序在对象上调用了一个需要花费很长时间来执行的方法并且希望让程序等待方法的返回，就应该使用异步编程，在很多情况下采用异步途径往往更有效率，
        事实上，所谓的同步就是指阻塞式操作，而异步就是非阻塞式操作。


# 2019-06-20
### 
1.请你谈谈对MQ的理解？以及你们在项目中是怎么用的？

        答：MQ（消息队列）是一种应用程序对应应用程序的通信方法的通信方法，由于在高并发环境下，由于来不及同步处理，请求往往发生阻塞，通过消息队列，我们可以一步请求处理，缓解系统压力；
        MQ（Message Queue），即消息队列是在消息的传输过程中保存消息的容器。通俗的说，就是一个容器，你把消息丢进去，不需要立即处理。然后有个程序去从你的容器里面把消息一条条读出来处理。
        一般用于应用系统解耦、消息异步分发，能够提高系统吞吐量。
        消息队列
        注册用户，发邮件（异步）
        登录，发短信通知（异步），加积分（异步）
        商品添加，异步更新solr，异步更新静态页面
        静态页面 — 库存 — 实时性交差
        接口，库存修改后，重新生成新的静态页面
        
### 
2.请你谈谈对Redis的认识？

        答：Redis是一种基于键值对的NoSQL数据库(非关系型数据库)；是一个key-value存储系统。Redis有两个特点:高能性、可靠性
        高能性：Redis将所有数据都存储在内存中，所以读写性特别高
        可靠性：Redis将内存中的数据利用RDB和AOF的形式保存到硬盘，这样就可以避免发生断点或机器故障时内存数据丢失的问题
        功能应用：
        （1）数据缓存功能，减少对数据库的访问压力
        （2）消息队列功能（轻量级）
            Redis提供了发布订阅功能和阻塞队列功能
        （3）计数器 — 应用保存用户凭证
            比如计算浏览数，如果每次操作都要做数据库的对应更新操作，那将会给数据库的性能带来极大的挑战
            缓存：优化网站性能，首页（不常变的信息）
            存储：单点登录，购物车
            计数器：登录次数限制，incr
            时效性：验证码expire
            订单号：数字
### 
3.redis应用场景场景？

        答：（1）缓存数据服务器：SSO单点登录
            （2）应对高速读写的场景：秒杀高可用
            （3）分布式锁：秒杀数据一致性
            （4）数据共享：库存数据
        
### 
4.请你谈谈单点登录的实现方案？你们怎么包括cookie的安全性？跨域取cookie的问题，你们怎么解决的？

        答：单点登录使用了Redis+Cookie实现，把用户信息放在Redis中，Key作为用户凭证存放在Cookie中放在客户端，通过获取Cookie凭证判断用户是否登录。
        Cookie的安全性，我们的凭证是唯一的UUID，使用工具类统一字符串命名，并且设置了Cookie，关闭document.cookie的取值功能。
        Cookie的跨域问题，在二级域名使用共享Cookie的将多个系统的域名统一作为二级域名，统一平台提供使用主域名，cookie.setPath("/")设置Cookie路径为根路径，
        通过cookie.setDomain(".父域名")是的项目之间跨域互相访问它们的Cookie.
        
### 
5.如何应对高并发问题？
   
        答：（1）HTML静态化，消耗最小的纯静态化的html页面避免大量的数据库访问请求
        （2）分离图片服务器，对于web服务器来说，图片是最消耗资源的，将图片资源和页面资源进行分类，进行不同的配置优化，保证更改的系统消耗和执行效率
        （3）数据库集群和库表散列，数据库集群由于在架构、成本、扩张性方面都会受到所采用的关系型的限制，在应用程序安装业务和功能模块将数据库进行分离，
        不同的模块对应不同的数据库或者表，再进行更小的数据库散列，最终可以再配置让系统随时增加数据库补充系统性能
        （4）缓存，使用外加的redis模块进行缓存，减轻数据库访问压力
        （5）负载均衡，在服务器集群中需一台服务器调度角色Nginx，用户所有请求先由它接收，在分配某台服务器去处理；
        实现负载均衡：http重定向实现，DNS匹配，反向代理
        （6）动静态分离，对于动态请求交给Tomcat而其它静态请求，搭建专门的静态资源服务器，使用nginx进行请求分发
    
### 
6.Zookeeper应用场景？

        答：（1）统一配置管理
            持久化节点存放配置信息，监听内容修改
        （2）集群管理
            临时节点机器（节点）退出或者加入，Master选举投票临时顺序节点选举时候直接使用编号最小的即可
        （3）分布式锁
            创建临时节点，创建成功者获得锁，执行业务操作，独占操作
            也可以进行顺序执行，通过最顺序临时节点的编号
        （4）命名服务
            /dubbo
                /provider：存放服务地址
                /consumer：存放消费地址（没有实际意义）
                /conf：存放配置信息
            ...
            consumer通过监听provider节点的内容修改动态读取地址，并且支持集群，只需要在provider中存放多个地址然后程序中通过代码实现随机调用即可
     
# 2019-06-24
### 
1.注册中心你了解了哪些？

        答：Consul、Eureka、ZooKeeper
        
### 
2.JDK中有哪几个线程池？

        答：JUC提供了调度对象Executors来创建线程池，可创建的线程池有四种
        （1）newFixedThreadPool创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中
        （2） newCachedThreadPool创建一个可缓存的线程池。这种类型的线程池特点是：
            1）工作线程的创建数量几乎没有限制（其实也有限制的，数目为Integer.MAX_VALUE），这样可灵活的往线程池中添加线程。
            2）如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为1分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务。则线程池重新创建一个工作线程。
        （3）newSingleThreadExecutor创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，如果这个线程异常结束，会有另一个取代它，保证顺序执行（我觉得这个点是它的特色）。
        单工作线程最大的特点是可保证顺序执行各个任务，并且在任意给定的时间不会有多个线程是活动的。
        （4）newScheduledThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似于Timer.
                
### 
3.Object的hashcode方法重写了，equals方法要不要改？

        答：不需要，Object类中有两个方法equals、hashCode，这两个方法都是用来比较两个对象是否相等的，如果两个对象相等(equal)，那么必须拥有相同的哈希吗（hash code）
        即使两个对象有相同的哈希吗(hash code)，它们不一定相等
        重写equals()方法就必须重写hashCode()，但重写hashcode方法不一定要重写equals方法
        
### 
4.SQL优化的常见方法有哪些？

        答：查询条件减少使用函数，避免权标扫描
        减少不必要的表连接
        有些数据操作的业务逻辑可以放到应用层进行实现，可以使用with as
        尽量避免使用游标，因为游标的效率较差
        不要把sql语句写的太复杂
        不能循环执行查询
        用exists代替in
        表关联关系不要太纠结
        查询多用索引列去查，用charindex或者like[0-9]来代替%%
        inner关联的表可以先查出来，再去关联left join的表
        可以进行表关联数据拆分，即先查出核心数据，再通过核心数据查其它数，这样会很快
        参考SQL执行顺序进行优化
        表关联时取别名，也能提高效率
        使用视图，给视图建立索引进行优化
        使用数据仓库的形式，建立单独的表存储数据，根据时间戳定期更新数据。将多表关联的数据几种抽取存入一张表中，查询时单表查询，提高了查询效率。
        对查询进行优化，应尽量避免全表扫描，首先应考虑在where及order by涉及的列上建立索引。
        应尽量避免在where子句中对字段进行null值判断，否则将导致引擎放弃使用索引而进行全表索淼，如：
            select id from t where num is null
            可以再num上设置默认值0，确保表中num列没有null值，然后这样查询：
            select id from t where num = 0;
         应尽量避免在where子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。
        
### 
5.项目中的监控：那个监控指标常见的有哪些？
   
        答：CPU、内存、IO等等。建议下载个nmon工具，里面有各个指标。
        数据库：Mysql（缓存命中、索引、单条SQL性能、数据库线程数、数据池连接数）。
        中间件：1、消息，2、负载均衡，3、缓存（包括线程数、连接数、日志）。
        网络：吞吐量、吞吐率。
        应用：jvm内存、日志、Full GC频率。
    
### 
6.Spring Boot除了自动配置，相比传统的Spring有什么其它的区别？

        答：为Spring生态系统的开发提供一种更简洁的方式，提供了很多非功能性特性，例如：嵌入式Server，Security，统计，健康检查，外部配置等等，主要欧体现在以下几点：
        （1）Spring Boot 可以建立独立的Spring应用程序；
        （2）内嵌了如Tomcat，Jetty和Undertow这样的容器，也就是说可以直接跑起来，用不着再做部署工作了；
        （3）无需再像Spring那样搞一堆繁琐的xml文件的配置；
        （4）可以自动配置Spring。Spring Boot 将原有的XML配置改为java配置，将bean注入改为使用注解注入的方式（@Autowire）,并将多个xml、properties配置浓缩在一个application.yml配置文件中；
        （5）提供了一些现有的功能，如度量工具，表单数据验证以及一些外部配置这样的一些第三方功能；
        （6）整合常用依赖（开发库，例如spring-webmvc、jackson-json、validation-api和tomcat等），提供的POM可以简化Maven的配置。当我们引入核心依赖时，SpringBoot会自动引入其它依赖。
 
 
 # 2019-06-26
 ### 
 1.mysql的三大引擎是什么？
 
         答：mysql常用的引擎有InnoDB，MyISAM，Memory，默认是InnoDB
         InnoDB：磁盘表，支持事务，支持行级锁，B+Tree索引
            优点：具有良好的ACID特性。适用于高并发，更新操作比较多的表。需要使用事务的表。对自动灾难恢复有要求的表。
            缺点：读写效率相对MYISAM比较差。占用的磁盘空间比较大。
         MyISAM：磁盘表，不支持事务，支持表级锁，B+Tree索引
            优点：占用空间小，处理速度快（相对InnoDB来说）
            缺点：不支持事务的完整性和并发性。
         MEMORY(Heap)：内存表，不支持事务，表级锁，Hash索引，不支持Blob,Text大类型
            优点：速度要求快的，临时数据
            缺点：丢失以后，对羡慕整体没有或者负面影响不大的时候。
         
         
 ### 
 2.redis的hash算法用的是啥？
 
         答：redis应该是使用一致性hash算法——MurmurHash3算法，具有低碰撞率优点，google改进的版本cityhash也是redis中用到的哈希算法。
         现有的主流的大数据系统都是用哪个的MurmurHash本身或者改进。
                 
 ### 
 3.nosql为什么比sql快？
 
         答：NoSql是非关系型数据，因为不需要满足关系型数据库数据一致性等复杂特性所以速度快；
         sql是关系型数据库，功能强大，但是效率上有瓶颈。
         
 ### 
 4.什么是索引？为什么nosql没有索引？nosql有索引滴
 
         答：索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而费聚簇索引对于单行的检索很快。
         聚簇索引：有主键时，根据主键创建聚簇索引；没有主键时，会用一个唯一且不为空的索引列作为主键，成为此表的聚簇索引；如果以上两个都不满足那innodb自己创建一个虚拟的聚集索引
         
         非聚簇索引：非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引
         
 ### 
 5.B+树和B树区别？
    
         答：B树的非叶子节点存储实际记录的指针，而B+树的叶子节点存储实际记录的指针
         B+树的叶子节点通过指针连起来了，适合扫描区间和顺序查找。
     
 ### 
 6.项目用Spring比较多，有没有了解Spring的原理？AOP和IOC的原理？
 
         答：(1)IOC(Inversion of Control)是指容器控制程序对象之间的关系，而不是传统实现中，由程序代码直接控制。控制权由应用代码中转到外部容器，控制权的转移是所谓反转。对于Spring而言，就是由Spring来控制
         对象的生命周期和对象之间的关系；IOC还有另外一个名字——“依赖注入(Dependency Injection)”。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，即由容器动态地将某种依赖关系注入到组件之中。
         (2)在Spring的工作方式中，所有的类都会在Spring容器中登记，告诉Spring这是个什么东西，你需要什么东西，然后Spring会在西戎运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的
         创建、销毁都由Spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是Spring。对于某个具体的对象而言，以前是它控制其它对象，现在是所有对象都被Spring控制，所以这叫控制反转。
         (3)在系统运行中，动态的向某个对象提供它所需要的其它对象。
         (4)依赖注入的思想是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。总而言之，在传统的对象创建方式中，通常由调用者来创建被调用者的实例，而在
         Spring中创建被调用者的工作由Spring来完成，然后注入调用者，即所谓的依赖注入or控制反转。注入方式有两种：依赖注入和设置注入；
         IOC的优点：降低了组件之间的耦合，降低了业务对象之间替换的复杂性，使之能够灵活的管理对象。

        AOP(Aspect Oriented Programming)
        (1)AOP面向方面编程基于IOC，是对OOP的有益补充；
        (2)AOP利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”,即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用
        的逻辑或责任封装起来，比如日志记录，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。
        (3)AOP代表的是一个横向的关系，将“对象”比作一个空心的圆柱体，其中封装的是对象的属性和行为；则面向方面编程的方法，就是将这个圆柱体以切面形式剖开，选择性的提供业务逻辑。而剖开的切面，就是所谓的“方面”了。然
        后它又巧夺天工的妙手将这些剖开的切面复原，不留痕迹，但完成了效果。
        (4)实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以再编译期间织入有关“方面”的代码
        (5)Spring实现AOP：JDK动态代理和CGLIB代理。
            JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理；其核心的两个类是InvocationHandler和Proxy.
            CGLIB代理：实现原理类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类。CGLIB是高效的代码生成包，底层是依靠ASM（开源的java字节码编辑类库）操作字节码实现的，性能比JDK强；需要引入包asm.jar和cglib.jar。
         使用Aspect注入式切面和@AspectJ注解驱动的切面实际上底层也是通过动态代理实现的。
        (6)AOP使用场景：
            Authentication 权限检查
            Caching 缓存
            Context passing 内容传递
            Error handling 错误处理
            Lazy loading 延迟加载
            Debugging 调试
            logging,tracing,profiling and monitoring 日志记录，跟踪，优化，校准
            Performance optimization 性能优化，效率检查
            Persistence 持久化
            Resource pooling 资源池
            Synchronization 同步
            Transactions 事务管理
            
            另外Filter的实现和struts2的拦截器的实现都是AOP思想的体现。

   
# 2019-06-28
 ### 
 1.什么是SpringBoot？
 
         答：用来简化Spring应用的初始搭建以及开发过程中用特定的方式来进行配置（properties或yml文件）
         创建独立的Spring应用程序main方法运行
         嵌入的Tomcat无需部署war文件
         简化maven配置
         自动配置Spring添加对应功能starter自动配置
         
 ### 
 2.SpringBoot常用的starter有哪些？
 
         答：spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持
         spring-boot-starter-data-jpa 数据库支持
         spring-boot-starter-data-redis redis数据库支持
         spring-boot-starter-data-solr solr支持
         mybatis-spring-boot-starter 第三方mybatis集成starter
                 
 ### 
 3.SpringBoot自动配置的原理？
 
         答：在Spring程序main方法中添加@SpringBootApplication或者@EnableAutoConfiguration，会自动去maven中读取每个starter中的spring.factories文件，该文件里配置了所有需要被创建Spring容器找那个的bean。
         
 ### 
 4.SpringBoot读取配置文件的方式？
 
         答：Springboot默认读取配置文件为application.properties或者是application.yml
         
 ### 
 5.SpringBoot集成MyBatis的过程？
    
         答：添加mybatis的starter maven依赖
                <dependency>
         			<groupId>org.mybatis.spring.boot</groupId>
         			<artifactId>mybatis-spring-boot-starter</artifactId>
         			<version>1.3.0</version>
         		</dependency>
         在mybatis的接口中添加@Mapper注解，在application.yml配置数据源信息
     
 ### 
 6.SpringBoot如何添加【修改代码】自动重启功能？
 
         答：添加开发者工具集 =====  spring-boot-devtools

   